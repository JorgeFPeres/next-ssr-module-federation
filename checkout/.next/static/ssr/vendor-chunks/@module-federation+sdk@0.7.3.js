"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@module-federation+sdk@0.7.3";
exports.ids = ["vendor-chunks/@module-federation+sdk@0.7.3"];
exports.modules = {

/***/ "../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/index.cjs.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/index.cjs.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar isomorphicRslog = __webpack_require__(/*! isomorphic-rslog */ \"../node_modules/.pnpm/isomorphic-rslog@0.0.6/node_modules/isomorphic-rslog/dist/node/index.cjs\");\nvar polyfills = __webpack_require__(/*! ./polyfills.cjs.js */ \"../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/polyfills.cjs.js\");\n\nconst FederationModuleManifest = 'federation-manifest.json';\nconst MANIFEST_EXT = '.json';\nconst BROWSER_LOG_KEY = 'FEDERATION_DEBUG';\nconst BROWSER_LOG_VALUE = '1';\nconst NameTransformSymbol = {\n    AT: '@',\n    HYPHEN: '-',\n    SLASH: '/'\n};\nconst NameTransformMap = {\n    [NameTransformSymbol.AT]: 'scope_',\n    [NameTransformSymbol.HYPHEN]: '_',\n    [NameTransformSymbol.SLASH]: '__'\n};\nconst EncodedNameTransformMap = {\n    [NameTransformMap[NameTransformSymbol.AT]]: NameTransformSymbol.AT,\n    [NameTransformMap[NameTransformSymbol.HYPHEN]]: NameTransformSymbol.HYPHEN,\n    [NameTransformMap[NameTransformSymbol.SLASH]]: NameTransformSymbol.SLASH\n};\nconst SEPARATOR = ':';\nconst ManifestFileName = 'mf-manifest.json';\nconst StatsFileName = 'mf-stats.json';\nconst MFModuleType = {\n    NPM: 'npm',\n    APP: 'app'\n};\nconst MODULE_DEVTOOL_IDENTIFIER = '__MF_DEVTOOLS_MODULE_INFO__';\nconst ENCODE_NAME_PREFIX = 'ENCODE_NAME_PREFIX';\nconst TEMP_DIR = '.federation';\nconst MFPrefetchCommon = {\n    identifier: 'MFDataPrefetch',\n    globalKey: '__PREFETCH__',\n    library: 'mf-data-prefetch',\n    exportsKey: '__PREFETCH_EXPORTS__',\n    fileName: 'bootstrap.js'\n};\n\nvar ContainerPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ContainerReferencePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar ModuleFederationPlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nvar SharePlugin = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\n\nfunction isBrowserEnv() {\n    return typeof window !== 'undefined';\n}\nfunction isBrowserDebug() {\n    try {\n        if (isBrowserEnv() && window.localStorage) {\n            return localStorage.getItem(BROWSER_LOG_KEY) === BROWSER_LOG_VALUE;\n        }\n    } catch (error) {\n        return false;\n    }\n    return false;\n}\nfunction isDebugMode() {\n    if (typeof process !== 'undefined' && process.env && process.env['FEDERATION_DEBUG']) {\n        return Boolean(process.env['FEDERATION_DEBUG']);\n    }\n    if (typeof FEDERATION_DEBUG !== 'undefined' && Boolean(FEDERATION_DEBUG)) {\n        return true;\n    }\n    return isBrowserDebug();\n}\nconst getProcessEnv = function() {\n    return typeof process !== 'undefined' && process.env ? process.env : {};\n};\n\nconst PREFIX = '[ Module Federation ]';\nfunction setDebug(loggerInstance) {\n    if (isDebugMode()) {\n        loggerInstance.level = 'verbose';\n    }\n}\nfunction setPrefix(loggerInstance, prefix) {\n    loggerInstance.labels = {\n        warn: `${prefix} Warn`,\n        error: `${prefix} Error`,\n        success: `${prefix} Success`,\n        info: `${prefix} Info`,\n        ready: `${prefix} Ready`,\n        debug: `${prefix} Debug`\n    };\n}\nfunction createLogger(prefix) {\n    const loggerInstance = isomorphicRslog.createLogger({\n        labels: {\n            warn: `${PREFIX} Warn`,\n            error: `${PREFIX} Error`,\n            success: `${PREFIX} Success`,\n            info: `${PREFIX} Info`,\n            ready: `${PREFIX} Ready`,\n            debug: `${PREFIX} Debug`\n        }\n    });\n    setDebug(loggerInstance);\n    setPrefix(loggerInstance, prefix);\n    return loggerInstance;\n}\nconst logger = createLogger(PREFIX);\n\nconst LOG_CATEGORY = '[ Federation Runtime ]';\n// entry: name:version   version : 1.0.0 | ^1.2.3\n// entry: name:entry  entry:  https://localhost:9000/federation-manifest.json\nconst parseEntry = (str, devVerOrUrl, separator = SEPARATOR)=>{\n    const strSplit = str.split(separator);\n    const devVersionOrUrl = getProcessEnv()['NODE_ENV'] === 'development' && devVerOrUrl;\n    const defaultVersion = '*';\n    const isEntry = (s)=>s.startsWith('http') || s.includes(MANIFEST_EXT);\n    // Check if the string starts with a type\n    if (strSplit.length >= 2) {\n        let [name, ...versionOrEntryArr] = strSplit;\n        if (str.startsWith(separator)) {\n            versionOrEntryArr = [\n                devVersionOrUrl || strSplit.slice(-1)[0]\n            ];\n            name = strSplit.slice(0, -1).join(separator);\n        }\n        let versionOrEntry = devVersionOrUrl || versionOrEntryArr.join(separator);\n        if (isEntry(versionOrEntry)) {\n            return {\n                name,\n                entry: versionOrEntry\n            };\n        } else {\n            // Apply version rule\n            // devVersionOrUrl => inputVersion => defaultVersion\n            return {\n                name,\n                version: versionOrEntry || defaultVersion\n            };\n        }\n    } else if (strSplit.length === 1) {\n        const [name] = strSplit;\n        if (devVersionOrUrl && isEntry(devVersionOrUrl)) {\n            return {\n                name,\n                entry: devVersionOrUrl\n            };\n        }\n        return {\n            name,\n            version: devVersionOrUrl || defaultVersion\n        };\n    } else {\n        throw `Invalid entry value: ${str}`;\n    }\n};\nconst composeKeyWithSeparator = function(...args) {\n    if (!args.length) {\n        return '';\n    }\n    return args.reduce((sum, cur)=>{\n        if (!cur) {\n            return sum;\n        }\n        if (!sum) {\n            return cur;\n        }\n        return `${sum}${SEPARATOR}${cur}`;\n    }, '');\n};\nconst encodeName = function(name, prefix = '', withExt = false) {\n    try {\n        const ext = withExt ? '.js' : '';\n        return `${prefix}${name.replace(new RegExp(`${NameTransformSymbol.AT}`, 'g'), NameTransformMap[NameTransformSymbol.AT]).replace(new RegExp(`${NameTransformSymbol.HYPHEN}`, 'g'), NameTransformMap[NameTransformSymbol.HYPHEN]).replace(new RegExp(`${NameTransformSymbol.SLASH}`, 'g'), NameTransformMap[NameTransformSymbol.SLASH])}${ext}`;\n    } catch (err) {\n        throw err;\n    }\n};\nconst decodeName = function(name, prefix, withExt) {\n    try {\n        let decodedName = name;\n        if (prefix) {\n            if (!decodedName.startsWith(prefix)) {\n                return decodedName;\n            }\n            decodedName = decodedName.replace(new RegExp(prefix, 'g'), '');\n        }\n        decodedName = decodedName.replace(new RegExp(`${NameTransformMap[NameTransformSymbol.AT]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.AT]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.SLASH]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.SLASH]]).replace(new RegExp(`${NameTransformMap[NameTransformSymbol.HYPHEN]}`, 'g'), EncodedNameTransformMap[NameTransformMap[NameTransformSymbol.HYPHEN]]);\n        if (withExt) {\n            decodedName = decodedName.replace('.js', '');\n        }\n        return decodedName;\n    } catch (err) {\n        throw err;\n    }\n};\nconst generateExposeFilename = (exposeName, withExt)=>{\n    if (!exposeName) {\n        return '';\n    }\n    let expose = exposeName;\n    if (expose === '.') {\n        expose = 'default_export';\n    }\n    if (expose.startsWith('./')) {\n        expose = expose.replace('./', '');\n    }\n    return encodeName(expose, '__federation_expose_', withExt);\n};\nconst generateShareFilename = (pkgName, withExt)=>{\n    if (!pkgName) {\n        return '';\n    }\n    return encodeName(pkgName, '__federation_shared_', withExt);\n};\nconst getResourceUrl = (module, sourceUrl)=>{\n    if ('getPublicPath' in module) {\n        let publicPath;\n        if (!module.getPublicPath.startsWith('function')) {\n            publicPath = new Function(module.getPublicPath)();\n        } else {\n            publicPath = new Function('return ' + module.getPublicPath)()();\n        }\n        return `${publicPath}${sourceUrl}`;\n    } else if ('publicPath' in module) {\n        return `${module.publicPath}${sourceUrl}`;\n    } else {\n        console.warn('Cannot get resource URL. If in debug mode, please ignore.', module, sourceUrl);\n        return '';\n    }\n};\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nconst assert = (condition, msg)=>{\n    if (!condition) {\n        error(msg);\n    }\n};\nconst error = (msg)=>{\n    throw new Error(`${LOG_CATEGORY}: ${msg}`);\n};\nconst warn = (msg)=>{\n    console.warn(`${LOG_CATEGORY}: ${msg}`);\n};\nfunction safeToString(info) {\n    try {\n        return JSON.stringify(info, null, 2);\n    } catch (e) {\n        return '';\n    }\n}\n// RegExp for version string\nconst VERSION_PATTERN_REGEXP = /^([\\d^=v<>~]|[*xX]$)/;\nfunction isRequiredVersion(str) {\n    return VERSION_PATTERN_REGEXP.test(str);\n}\n\nconst simpleJoinRemoteEntry = (rPath, rName)=>{\n    if (!rPath) {\n        return rName;\n    }\n    const transformPath = (str)=>{\n        if (str === '.') {\n            return '';\n        }\n        if (str.startsWith('./')) {\n            return str.replace('./', '');\n        }\n        if (str.startsWith('/')) {\n            const strWithoutSlash = str.slice(1);\n            if (strWithoutSlash.endsWith('/')) {\n                return strWithoutSlash.slice(0, -1);\n            }\n            return strWithoutSlash;\n        }\n        return str;\n    };\n    const transformedPath = transformPath(rPath);\n    if (!transformedPath) {\n        return rName;\n    }\n    if (transformedPath.endsWith('/')) {\n        return `${transformedPath}${rName}`;\n    }\n    return `${transformedPath}/${rName}`;\n};\nfunction inferAutoPublicPath(url) {\n    return url.replace(/#.*$/, '').replace(/\\?.*$/, '').replace(/\\/[^\\/]+$/, '/');\n}\n// Priority: overrides > remotes\n// eslint-disable-next-line max-lines-per-function\nfunction generateSnapshotFromManifest(manifest, options = {}) {\n    var _manifest_metaData, _manifest_metaData1;\n    const { remotes = {}, overrides = {}, version } = options;\n    let remoteSnapshot;\n    const getPublicPath = ()=>{\n        if ('publicPath' in manifest.metaData) {\n            if (manifest.metaData.publicPath === 'auto' && version) {\n                // use same implementation as publicPath auto runtime module implements\n                return inferAutoPublicPath(version);\n            }\n            return manifest.metaData.publicPath;\n        } else {\n            return manifest.metaData.getPublicPath;\n        }\n    };\n    const overridesKeys = Object.keys(overrides);\n    let remotesInfo = {};\n    // If remotes are not provided, only the remotes in the manifest will be read\n    if (!Object.keys(remotes).length) {\n        var _manifest_remotes;\n        remotesInfo = ((_manifest_remotes = manifest.remotes) == null ? void 0 : _manifest_remotes.reduce((res, next)=>{\n            let matchedVersion;\n            const name = next.federationContainerName;\n            // overrides have higher priority\n            if (overridesKeys.includes(name)) {\n                matchedVersion = overrides[name];\n            } else {\n                if ('version' in next) {\n                    matchedVersion = next.version;\n                } else {\n                    matchedVersion = next.entry;\n                }\n            }\n            res[name] = {\n                matchedVersion\n            };\n            return res;\n        }, {})) || {};\n    }\n    // If remotes (deploy scenario) are specified, they need to be traversed again\n    Object.keys(remotes).forEach((key)=>remotesInfo[key] = {\n            // overrides will override dependencies\n            matchedVersion: overridesKeys.includes(key) ? overrides[key] : remotes[key]\n        });\n    const { remoteEntry: { path: remoteEntryPath, name: remoteEntryName, type: remoteEntryType }, types: remoteTypes, buildInfo: { buildVersion }, globalName, ssrRemoteEntry } = manifest.metaData;\n    const { exposes } = manifest;\n    let basicRemoteSnapshot = {\n        version: version ? version : '',\n        buildVersion,\n        globalName,\n        remoteEntry: simpleJoinRemoteEntry(remoteEntryPath, remoteEntryName),\n        remoteEntryType,\n        remoteTypes: simpleJoinRemoteEntry(remoteTypes.path, remoteTypes.name),\n        remoteTypesZip: remoteTypes.zip || '',\n        remoteTypesAPI: remoteTypes.api || '',\n        remotesInfo,\n        shared: manifest == null ? void 0 : manifest.shared.map((item)=>({\n                assets: item.assets,\n                sharedName: item.name,\n                version: item.version\n            })),\n        modules: exposes == null ? void 0 : exposes.map((expose)=>({\n                moduleName: expose.name,\n                modulePath: expose.path,\n                assets: expose.assets\n            }))\n    };\n    if ((_manifest_metaData = manifest.metaData) == null ? void 0 : _manifest_metaData.prefetchInterface) {\n        const prefetchInterface = manifest.metaData.prefetchInterface;\n        basicRemoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {\n            prefetchInterface\n        });\n    }\n    if ((_manifest_metaData1 = manifest.metaData) == null ? void 0 : _manifest_metaData1.prefetchEntry) {\n        const { path, name, type } = manifest.metaData.prefetchEntry;\n        basicRemoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {\n            prefetchEntry: simpleJoinRemoteEntry(path, name),\n            prefetchEntryType: type\n        });\n    }\n    if ('publicPath' in manifest.metaData) {\n        remoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {\n            publicPath: getPublicPath()\n        });\n    } else {\n        remoteSnapshot = polyfills._extends({}, basicRemoteSnapshot, {\n            getPublicPath: getPublicPath()\n        });\n    }\n    if (ssrRemoteEntry) {\n        const fullSSRRemoteEntry = simpleJoinRemoteEntry(ssrRemoteEntry.path, ssrRemoteEntry.name);\n        remoteSnapshot.ssrRemoteEntry = fullSSRRemoteEntry;\n        remoteSnapshot.ssrRemoteEntryType = ssrRemoteEntry.type || 'commonjs-module';\n    }\n    return remoteSnapshot;\n}\nfunction isManifestProvider(moduleInfo) {\n    if ('remoteEntry' in moduleInfo && moduleInfo.remoteEntry.includes(MANIFEST_EXT)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nasync function safeWrapper(callback, disableWarn) {\n    try {\n        const res = await callback();\n        return res;\n    } catch (e) {\n        !disableWarn && warn(e);\n        return;\n    }\n}\nfunction isStaticResourcesEqual(url1, url2) {\n    const REG_EXP = /^(https?:)?\\/\\//i;\n    // Transform url1 and url2 into relative paths\n    const relativeUrl1 = url1.replace(REG_EXP, '').replace(/\\/$/, '');\n    const relativeUrl2 = url2.replace(REG_EXP, '').replace(/\\/$/, '');\n    // Check if the relative paths are identical\n    return relativeUrl1 === relativeUrl2;\n}\nfunction createScript(info) {\n    // Retrieve the existing script element by its src attribute\n    let script = null;\n    let needAttach = true;\n    let timeout = 20000;\n    let timeoutId;\n    const scripts = document.getElementsByTagName('script');\n    for(let i = 0; i < scripts.length; i++){\n        const s = scripts[i];\n        const scriptSrc = s.getAttribute('src');\n        if (scriptSrc && isStaticResourcesEqual(scriptSrc, info.url)) {\n            script = s;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!script) {\n        const attrs = info.attrs;\n        script = document.createElement('script');\n        script.type = (attrs == null ? void 0 : attrs['type']) === 'module' ? 'module' : 'text/javascript';\n        let createScriptRes = undefined;\n        if (info.createScriptHook) {\n            createScriptRes = info.createScriptHook(info.url, info.attrs);\n            if (createScriptRes instanceof HTMLScriptElement) {\n                script = createScriptRes;\n            } else if (typeof createScriptRes === 'object') {\n                if ('script' in createScriptRes && createScriptRes.script) {\n                    script = createScriptRes.script;\n                }\n                if ('timeout' in createScriptRes && createScriptRes.timeout) {\n                    timeout = createScriptRes.timeout;\n                }\n            }\n        }\n        if (!script.src) {\n            script.src = info.url;\n        }\n        if (attrs && !createScriptRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (script) {\n                    if (name === 'async' || name === 'defer') {\n                        script[name] = attrs[name];\n                    // Attributes that do not exist are considered overridden\n                    } else if (!script.getAttribute(name)) {\n                        script.setAttribute(name, attrs[name]);\n                    }\n                }\n            });\n        }\n    }\n    const onScriptComplete = async (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        var _info_cb;\n        clearTimeout(timeoutId);\n        // Prevent memory leaks in IE.\n        if (script) {\n            script.onerror = null;\n            script.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteScript = true } = info;\n                if (needDeleteScript) {\n                    (script == null ? void 0 : script.parentNode) && script.parentNode.removeChild(script);\n                }\n            });\n            if (prev && typeof prev === 'function') {\n                var _info_cb1;\n                const result = prev(event);\n                if (result instanceof Promise) {\n                    var _info_cb2;\n                    const res = await result;\n                    info == null ? void 0 : (_info_cb2 = info.cb) == null ? void 0 : _info_cb2.call(info);\n                    return res;\n                }\n                info == null ? void 0 : (_info_cb1 = info.cb) == null ? void 0 : _info_cb1.call(info);\n                return result;\n            }\n        }\n        info == null ? void 0 : (_info_cb = info.cb) == null ? void 0 : _info_cb.call(info);\n    };\n    script.onerror = onScriptComplete.bind(null, script.onerror);\n    script.onload = onScriptComplete.bind(null, script.onload);\n    timeoutId = setTimeout(()=>{\n        onScriptComplete(null, new Error(`Remote script \"${info.url}\" time-outed.`));\n    }, timeout);\n    return {\n        script,\n        needAttach\n    };\n}\nfunction createLink(info) {\n    // <link rel=\"preload\" href=\"script.js\" as=\"script\">\n    // Retrieve the existing script element by its src attribute\n    let link = null;\n    let needAttach = true;\n    const links = document.getElementsByTagName('link');\n    for(let i = 0; i < links.length; i++){\n        const l = links[i];\n        const linkHref = l.getAttribute('href');\n        const linkRef = l.getAttribute('ref');\n        if (linkHref && isStaticResourcesEqual(linkHref, info.url) && linkRef === info.attrs['ref']) {\n            link = l;\n            needAttach = false;\n            break;\n        }\n    }\n    if (!link) {\n        link = document.createElement('link');\n        link.setAttribute('href', info.url);\n        let createLinkRes = undefined;\n        const attrs = info.attrs;\n        if (info.createLinkHook) {\n            createLinkRes = info.createLinkHook(info.url, attrs);\n            if (createLinkRes instanceof HTMLLinkElement) {\n                link = createLinkRes;\n            }\n        }\n        if (attrs && !createLinkRes) {\n            Object.keys(attrs).forEach((name)=>{\n                if (link && !link.getAttribute(name)) {\n                    link.setAttribute(name, attrs[name]);\n                }\n            });\n        }\n    }\n    const onLinkComplete = (prev, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event)=>{\n        // Prevent memory leaks in IE.\n        if (link) {\n            link.onerror = null;\n            link.onload = null;\n            safeWrapper(()=>{\n                const { needDeleteLink = true } = info;\n                if (needDeleteLink) {\n                    (link == null ? void 0 : link.parentNode) && link.parentNode.removeChild(link);\n                }\n            });\n            if (prev) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const res = prev(event);\n                info.cb();\n                return res;\n            }\n        }\n        info.cb();\n    };\n    link.onerror = onLinkComplete.bind(null, link.onerror);\n    link.onload = onLinkComplete.bind(null, link.onload);\n    return {\n        link,\n        needAttach\n    };\n}\nfunction loadScript(url, info) {\n    const { attrs = {}, createScriptHook } = info;\n    return new Promise((resolve, _reject)=>{\n        const { script, needAttach } = createScript({\n            url,\n            cb: resolve,\n            attrs: polyfills._extends({\n                fetchpriority: 'high'\n            }, attrs),\n            createScriptHook,\n            needDeleteScript: true\n        });\n        needAttach && document.head.appendChild(script);\n    });\n}\n\nfunction importNodeModule(name) {\n    if (!name) {\n        throw new Error('import specifier is required');\n    }\n    const importModule = new Function('name', `return import(name)`);\n    return importModule(name).then((res)=>res).catch((error)=>{\n        console.error(`Error importing module ${name}:`, error);\n        throw error;\n    });\n}\nconst loadNodeFetch = async ()=>{\n    const fetchModule = await importNodeModule('node-fetch');\n    return fetchModule.default || fetchModule;\n};\nconst lazyLoaderHookFetch = async (input, init, loaderHook)=>{\n    const hook = (url, init)=>{\n        return loaderHook.lifecycle.fetch.emit(url, init);\n    };\n    const res = await hook(input, init || {});\n    if (!res || !(res instanceof Response)) {\n        const fetchFunction = typeof fetch === 'undefined' ? await loadNodeFetch() : fetch;\n        return fetchFunction(input, init || {});\n    }\n    return res;\n};\nfunction createScriptNode(url, cb, attrs, loaderHook) {\n    if (loaderHook == null ? void 0 : loaderHook.createScriptHook) {\n        const hookResult = loaderHook.createScriptHook(url);\n        if (hookResult && typeof hookResult === 'object' && 'url' in hookResult) {\n            url = hookResult.url;\n        }\n    }\n    let urlObj;\n    try {\n        urlObj = new URL(url);\n    } catch (e) {\n        console.error('Error constructing URL:', e);\n        cb(new Error(`Invalid URL: ${e}`));\n        return;\n    }\n    const getFetch = async ()=>{\n        if (loaderHook == null ? void 0 : loaderHook.fetch) {\n            return (input, init)=>lazyLoaderHookFetch(input, init, loaderHook);\n        }\n        return typeof fetch === 'undefined' ? loadNodeFetch() : fetch;\n    };\n    const handleScriptFetch = async (f, urlObj)=>{\n        try {\n            var //@ts-ignore\n            _vm_constants;\n            const res = await f(urlObj.href);\n            const data = await res.text();\n            const [path, vm] = await Promise.all([\n                importNodeModule('path'),\n                importNodeModule('vm')\n            ]);\n            const scriptContext = {\n                exports: {},\n                module: {\n                    exports: {}\n                }\n            };\n            const urlDirname = urlObj.pathname.split('/').slice(0, -1).join('/');\n            const filename = path.basename(urlObj.pathname);\n            var _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER;\n            const script = new vm.Script(`(function(exports, module, require, __dirname, __filename) {${data}\\n})`, {\n                filename,\n                importModuleDynamically: (_vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER = (_vm_constants = vm.constants) == null ? void 0 : _vm_constants.USE_MAIN_CONTEXT_DEFAULT_LOADER) != null ? _vm_constants_USE_MAIN_CONTEXT_DEFAULT_LOADER : importNodeModule\n            });\n            script.runInThisContext()(scriptContext.exports, scriptContext.module, eval('require'), urlDirname, filename);\n            const exportedInterface = scriptContext.module.exports || scriptContext.exports;\n            if (attrs && exportedInterface && attrs['globalName']) {\n                const container = exportedInterface[attrs['globalName']] || exportedInterface;\n                cb(undefined, container);\n                return;\n            }\n            cb(undefined, exportedInterface);\n        } catch (e) {\n            cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));\n        }\n    };\n    getFetch().then(async (f)=>{\n        if ((attrs == null ? void 0 : attrs['type']) === 'esm' || (attrs == null ? void 0 : attrs['type']) === 'module') {\n            return loadModule(urlObj.href, {\n                fetch: f,\n                vm: await importNodeModule('vm')\n            }).then(async (module)=>{\n                await module.evaluate();\n                cb(undefined, module.namespace);\n            }).catch((e)=>{\n                cb(e instanceof Error ? e : new Error(`Script execution error: ${e}`));\n            });\n        }\n        handleScriptFetch(f, urlObj);\n    }).catch((err)=>{\n        cb(err);\n    });\n}\nfunction loadScriptNode(url, info) {\n    return new Promise((resolve, reject)=>{\n        createScriptNode(url, (error, scriptContext)=>{\n            if (error) {\n                reject(error);\n            } else {\n                var _info_attrs, _info_attrs1;\n                const remoteEntryKey = (info == null ? void 0 : (_info_attrs = info.attrs) == null ? void 0 : _info_attrs['globalName']) || `__FEDERATION_${info == null ? void 0 : (_info_attrs1 = info.attrs) == null ? void 0 : _info_attrs1['name']}:custom__`;\n                const entryExports = globalThis[remoteEntryKey] = scriptContext;\n                resolve(entryExports);\n            }\n        }, info.attrs, info.loaderHook);\n    });\n}\nasync function loadModule(url, options) {\n    const { fetch: fetch1, vm } = options;\n    const response = await fetch1(url);\n    const code = await response.text();\n    const module = new vm.SourceTextModule(code, {\n        // @ts-ignore\n        importModuleDynamically: async (specifier, script)=>{\n            const resolvedUrl = new URL(specifier, url).href;\n            return loadModule(resolvedUrl, options);\n        }\n    });\n    await module.link(async (specifier)=>{\n        const resolvedUrl = new URL(specifier, url).href;\n        const module = await loadModule(resolvedUrl, options);\n        return module;\n    });\n    return module;\n}\n\nfunction normalizeOptions(enableDefault, defaultOptions, key) {\n    return function(options) {\n        if (options === false) {\n            return false;\n        }\n        if (typeof options === 'undefined') {\n            if (enableDefault) {\n                return defaultOptions;\n            } else {\n                return false;\n            }\n        }\n        if (options === true) {\n            return defaultOptions;\n        }\n        if (options && typeof options === 'object') {\n            return polyfills._extends({}, defaultOptions, options);\n        }\n        throw new Error(`Unexpected type for \\`${key}\\`, expect boolean/undefined/object, got: ${typeof options}`);\n    };\n}\n\nexports.BROWSER_LOG_KEY = BROWSER_LOG_KEY;\nexports.BROWSER_LOG_VALUE = BROWSER_LOG_VALUE;\nexports.ENCODE_NAME_PREFIX = ENCODE_NAME_PREFIX;\nexports.EncodedNameTransformMap = EncodedNameTransformMap;\nexports.FederationModuleManifest = FederationModuleManifest;\nexports.MANIFEST_EXT = MANIFEST_EXT;\nexports.MFModuleType = MFModuleType;\nexports.MFPrefetchCommon = MFPrefetchCommon;\nexports.MODULE_DEVTOOL_IDENTIFIER = MODULE_DEVTOOL_IDENTIFIER;\nexports.ManifestFileName = ManifestFileName;\nexports.NameTransformMap = NameTransformMap;\nexports.NameTransformSymbol = NameTransformSymbol;\nexports.SEPARATOR = SEPARATOR;\nexports.StatsFileName = StatsFileName;\nexports.TEMP_DIR = TEMP_DIR;\nexports.assert = assert;\nexports.composeKeyWithSeparator = composeKeyWithSeparator;\nexports.containerPlugin = ContainerPlugin;\nexports.containerReferencePlugin = ContainerReferencePlugin;\nexports.createLink = createLink;\nexports.createLogger = createLogger;\nexports.createScript = createScript;\nexports.createScriptNode = createScriptNode;\nexports.decodeName = decodeName;\nexports.encodeName = encodeName;\nexports.error = error;\nexports.generateExposeFilename = generateExposeFilename;\nexports.generateShareFilename = generateShareFilename;\nexports.generateSnapshotFromManifest = generateSnapshotFromManifest;\nexports.getProcessEnv = getProcessEnv;\nexports.getResourceUrl = getResourceUrl;\nexports.inferAutoPublicPath = inferAutoPublicPath;\nexports.isBrowserEnv = isBrowserEnv;\nexports.isDebugMode = isDebugMode;\nexports.isManifestProvider = isManifestProvider;\nexports.isRequiredVersion = isRequiredVersion;\nexports.isStaticResourcesEqual = isStaticResourcesEqual;\nexports.loadScript = loadScript;\nexports.loadScriptNode = loadScriptNode;\nexports.logger = logger;\nexports.moduleFederationPlugin = ModuleFederationPlugin;\nexports.normalizeOptions = normalizeOptions;\nexports.parseEntry = parseEntry;\nexports.safeToString = safeToString;\nexports.safeWrapper = safeWrapper;\nexports.sharePlugin = SharePlugin;\nexports.simpleJoinRemoteEntry = simpleJoinRemoteEntry;\nexports.warn = warn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb2R1bGUtZmVkZXJhdGlvbitzZGtAMC43LjMvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9pbmRleC5janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLG1CQUFPLENBQUMsd0hBQWtCO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLHdJQUFvQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixRQUFRO0FBQzVCLGlCQUFpQixRQUFRO0FBQ3pCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QixzQkFBc0IsUUFBUTtBQUM5Qix3QkFBd0IsUUFBUTtBQUNoQyxxQkFBcUIsUUFBUTtBQUM3QixzQkFBc0IsUUFBUTtBQUM5QixzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLEtBQUs7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QW9CO0FBQ3BCLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGNBQWM7QUFDZCw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoZWNrb3V0Ly4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbW9kdWxlLWZlZGVyYXRpb24rc2RrQDAuNy4zL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vc2RrL2Rpc3QvaW5kZXguY2pzLmpzP2MwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNvbW9ycGhpY1JzbG9nID0gcmVxdWlyZSgnaXNvbW9ycGhpYy1yc2xvZycpO1xudmFyIHBvbHlmaWxscyA9IHJlcXVpcmUoJy4vcG9seWZpbGxzLmNqcy5qcycpO1xuXG5jb25zdCBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSAnZmVkZXJhdGlvbi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IE1BTklGRVNUX0VYVCA9ICcuanNvbic7XG5jb25zdCBCUk9XU0VSX0xPR19LRVkgPSAnRkVERVJBVElPTl9ERUJVRyc7XG5jb25zdCBCUk9XU0VSX0xPR19WQUxVRSA9ICcxJztcbmNvbnN0IE5hbWVUcmFuc2Zvcm1TeW1ib2wgPSB7XG4gICAgQVQ6ICdAJyxcbiAgICBIWVBIRU46ICctJyxcbiAgICBTTEFTSDogJy8nXG59O1xuY29uc3QgTmFtZVRyYW5zZm9ybU1hcCA9IHtcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF06ICdzY29wZV8nLFxuICAgIFtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTl06ICdfJyxcbiAgICBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF06ICdfXydcbn07XG5jb25zdCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCA9IHtcbiAgICBbTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUXV06IE5hbWVUcmFuc2Zvcm1TeW1ib2wuQVQsXG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dXTogTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU4sXG4gICAgW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5TTEFTSF1dOiBOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXG59O1xuY29uc3QgU0VQQVJBVE9SID0gJzonO1xuY29uc3QgTWFuaWZlc3RGaWxlTmFtZSA9ICdtZi1tYW5pZmVzdC5qc29uJztcbmNvbnN0IFN0YXRzRmlsZU5hbWUgPSAnbWYtc3RhdHMuanNvbic7XG5jb25zdCBNRk1vZHVsZVR5cGUgPSB7XG4gICAgTlBNOiAnbnBtJyxcbiAgICBBUFA6ICdhcHAnXG59O1xuY29uc3QgTU9EVUxFX0RFVlRPT0xfSURFTlRJRklFUiA9ICdfX01GX0RFVlRPT0xTX01PRFVMRV9JTkZPX18nO1xuY29uc3QgRU5DT0RFX05BTUVfUFJFRklYID0gJ0VOQ09ERV9OQU1FX1BSRUZJWCc7XG5jb25zdCBURU1QX0RJUiA9ICcuZmVkZXJhdGlvbic7XG5jb25zdCBNRlByZWZldGNoQ29tbW9uID0ge1xuICAgIGlkZW50aWZpZXI6ICdNRkRhdGFQcmVmZXRjaCcsXG4gICAgZ2xvYmFsS2V5OiAnX19QUkVGRVRDSF9fJyxcbiAgICBsaWJyYXJ5OiAnbWYtZGF0YS1wcmVmZXRjaCcsXG4gICAgZXhwb3J0c0tleTogJ19fUFJFRkVUQ0hfRVhQT1JUU19fJyxcbiAgICBmaWxlTmFtZTogJ2Jvb3RzdHJhcC5qcydcbn07XG5cbnZhciBDb250YWluZXJQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBDb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbnZhciBNb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG52YXIgU2hhcmVQbHVnaW4gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0Jyb3dzZXJEZWJ1ZygpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoaXNCcm93c2VyRW52KCkgJiYgd2luZG93LmxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKEJST1dTRVJfTE9HX0tFWSkgPT09IEJST1dTRVJfTE9HX1ZBTFVFO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlYnVnTW9kZSgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52WydGRURFUkFUSU9OX0RFQlVHJ10pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocHJvY2Vzcy5lbnZbJ0ZFREVSQVRJT05fREVCVUcnXSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRkVERVJBVElPTl9ERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgQm9vbGVhbihGRURFUkFUSU9OX0RFQlVHKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQnJvd3NlckRlYnVnKCk7XG59XG5jb25zdCBnZXRQcm9jZXNzRW52ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudiA/IHByb2Nlc3MuZW52IDoge307XG59O1xuXG5jb25zdCBQUkVGSVggPSAnWyBNb2R1bGUgRmVkZXJhdGlvbiBdJztcbmZ1bmN0aW9uIHNldERlYnVnKGxvZ2dlckluc3RhbmNlKSB7XG4gICAgaWYgKGlzRGVidWdNb2RlKCkpIHtcbiAgICAgICAgbG9nZ2VySW5zdGFuY2UubGV2ZWwgPSAndmVyYm9zZSc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0UHJlZml4KGxvZ2dlckluc3RhbmNlLCBwcmVmaXgpIHtcbiAgICBsb2dnZXJJbnN0YW5jZS5sYWJlbHMgPSB7XG4gICAgICAgIHdhcm46IGAke3ByZWZpeH0gV2FybmAsXG4gICAgICAgIGVycm9yOiBgJHtwcmVmaXh9IEVycm9yYCxcbiAgICAgICAgc3VjY2VzczogYCR7cHJlZml4fSBTdWNjZXNzYCxcbiAgICAgICAgaW5mbzogYCR7cHJlZml4fSBJbmZvYCxcbiAgICAgICAgcmVhZHk6IGAke3ByZWZpeH0gUmVhZHlgLFxuICAgICAgICBkZWJ1ZzogYCR7cHJlZml4fSBEZWJ1Z2BcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKHByZWZpeCkge1xuICAgIGNvbnN0IGxvZ2dlckluc3RhbmNlID0gaXNvbW9ycGhpY1JzbG9nLmNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgd2FybjogYCR7UFJFRklYfSBXYXJuYCxcbiAgICAgICAgICAgIGVycm9yOiBgJHtQUkVGSVh9IEVycm9yYCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGAke1BSRUZJWH0gU3VjY2Vzc2AsXG4gICAgICAgICAgICBpbmZvOiBgJHtQUkVGSVh9IEluZm9gLFxuICAgICAgICAgICAgcmVhZHk6IGAke1BSRUZJWH0gUmVhZHlgLFxuICAgICAgICAgICAgZGVidWc6IGAke1BSRUZJWH0gRGVidWdgXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBzZXREZWJ1Zyhsb2dnZXJJbnN0YW5jZSk7XG4gICAgc2V0UHJlZml4KGxvZ2dlckluc3RhbmNlLCBwcmVmaXgpO1xuICAgIHJldHVybiBsb2dnZXJJbnN0YW5jZTtcbn1cbmNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcihQUkVGSVgpO1xuXG5jb25zdCBMT0dfQ0FURUdPUlkgPSAnWyBGZWRlcmF0aW9uIFJ1bnRpbWUgXSc7XG4vLyBlbnRyeTogbmFtZTp2ZXJzaW9uICAgdmVyc2lvbiA6IDEuMC4wIHwgXjEuMi4zXG4vLyBlbnRyeTogbmFtZTplbnRyeSAgZW50cnk6ICBodHRwczovL2xvY2FsaG9zdDo5MDAwL2ZlZGVyYXRpb24tbWFuaWZlc3QuanNvblxuY29uc3QgcGFyc2VFbnRyeSA9IChzdHIsIGRldlZlck9yVXJsLCBzZXBhcmF0b3IgPSBTRVBBUkFUT1IpPT57XG4gICAgY29uc3Qgc3RyU3BsaXQgPSBzdHIuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICBjb25zdCBkZXZWZXJzaW9uT3JVcmwgPSBnZXRQcm9jZXNzRW52KClbJ05PREVfRU5WJ10gPT09ICdkZXZlbG9wbWVudCcgJiYgZGV2VmVyT3JVcmw7XG4gICAgY29uc3QgZGVmYXVsdFZlcnNpb24gPSAnKic7XG4gICAgY29uc3QgaXNFbnRyeSA9IChzKT0+cy5zdGFydHNXaXRoKCdodHRwJykgfHwgcy5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgc3RhcnRzIHdpdGggYSB0eXBlXG4gICAgaWYgKHN0clNwbGl0Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIGxldCBbbmFtZSwgLi4udmVyc2lvbk9yRW50cnlBcnJdID0gc3RyU3BsaXQ7XG4gICAgICAgIGlmIChzdHIuc3RhcnRzV2l0aChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICB2ZXJzaW9uT3JFbnRyeUFyciA9IFtcbiAgICAgICAgICAgICAgICBkZXZWZXJzaW9uT3JVcmwgfHwgc3RyU3BsaXQuc2xpY2UoLTEpWzBdXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbmFtZSA9IHN0clNwbGl0LnNsaWNlKDAsIC0xKS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZlcnNpb25PckVudHJ5ID0gZGV2VmVyc2lvbk9yVXJsIHx8IHZlcnNpb25PckVudHJ5QXJyLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGlzRW50cnkodmVyc2lvbk9yRW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZW50cnk6IHZlcnNpb25PckVudHJ5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQXBwbHkgdmVyc2lvbiBydWxlXG4gICAgICAgICAgICAvLyBkZXZWZXJzaW9uT3JVcmwgPT4gaW5wdXRWZXJzaW9uID0+IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdmVyc2lvbk9yRW50cnkgfHwgZGVmYXVsdFZlcnNpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCBbbmFtZV0gPSBzdHJTcGxpdDtcbiAgICAgICAgaWYgKGRldlZlcnNpb25PclVybCAmJiBpc0VudHJ5KGRldlZlcnNpb25PclVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBlbnRyeTogZGV2VmVyc2lvbk9yVXJsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmVyc2lvbjogZGV2VmVyc2lvbk9yVXJsIHx8IGRlZmF1bHRWZXJzaW9uXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgYEludmFsaWQgZW50cnkgdmFsdWU6ICR7c3RyfWA7XG4gICAgfVxufTtcbmNvbnN0IGNvbXBvc2VLZXlXaXRoU2VwYXJhdG9yID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gYXJncy5yZWR1Y2UoKHN1bSwgY3VyKT0+e1xuICAgICAgICBpZiAoIWN1cikge1xuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1bSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7c3VtfSR7U0VQQVJBVE9SfSR7Y3VyfWA7XG4gICAgfSwgJycpO1xufTtcbmNvbnN0IGVuY29kZU5hbWUgPSBmdW5jdGlvbihuYW1lLCBwcmVmaXggPSAnJywgd2l0aEV4dCA9IGZhbHNlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXh0ID0gd2l0aEV4dCA/ICcuanMnIDogJyc7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtU3ltYm9sLkFUfWAsICdnJyksIE5hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF0pLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtU3ltYm9sLkhZUEhFTn1gLCAnZycpLCBOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuSFlQSEVOXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0h9YCwgJ2cnKSwgTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXSl9JHtleHR9YDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn07XG5jb25zdCBkZWNvZGVOYW1lID0gZnVuY3Rpb24obmFtZSwgcHJlZml4LCB3aXRoRXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IGRlY29kZWROYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKCFkZWNvZGVkTmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChwcmVmaXgsICdnJyksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UobmV3IFJlZ0V4cChgJHtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuQVRdfWAsICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5BVF1dKS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7TmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtU3ltYm9sLlNMQVNIXX1gLCAnZycpLCBFbmNvZGVkTmFtZVRyYW5zZm9ybU1hcFtOYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1TeW1ib2wuU0xBU0hdXSkucmVwbGFjZShuZXcgUmVnRXhwKGAke05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dfWAsICdnJyksIEVuY29kZWROYW1lVHJhbnNmb3JtTWFwW05hbWVUcmFuc2Zvcm1NYXBbTmFtZVRyYW5zZm9ybVN5bWJvbC5IWVBIRU5dXSk7XG4gICAgICAgIGlmICh3aXRoRXh0KSB7XG4gICAgICAgICAgICBkZWNvZGVkTmFtZSA9IGRlY29kZWROYW1lLnJlcGxhY2UoJy5qcycsICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2RlZE5hbWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuY29uc3QgZ2VuZXJhdGVFeHBvc2VGaWxlbmFtZSA9IChleHBvc2VOYW1lLCB3aXRoRXh0KT0+e1xuICAgIGlmICghZXhwb3NlTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGxldCBleHBvc2UgPSBleHBvc2VOYW1lO1xuICAgIGlmIChleHBvc2UgPT09ICcuJykge1xuICAgICAgICBleHBvc2UgPSAnZGVmYXVsdF9leHBvcnQnO1xuICAgIH1cbiAgICBpZiAoZXhwb3NlLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgZXhwb3NlID0gZXhwb3NlLnJlcGxhY2UoJy4vJywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlTmFtZShleHBvc2UsICdfX2ZlZGVyYXRpb25fZXhwb3NlXycsIHdpdGhFeHQpO1xufTtcbmNvbnN0IGdlbmVyYXRlU2hhcmVGaWxlbmFtZSA9IChwa2dOYW1lLCB3aXRoRXh0KT0+e1xuICAgIGlmICghcGtnTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVOYW1lKHBrZ05hbWUsICdfX2ZlZGVyYXRpb25fc2hhcmVkXycsIHdpdGhFeHQpO1xufTtcbmNvbnN0IGdldFJlc291cmNlVXJsID0gKG1vZHVsZSwgc291cmNlVXJsKT0+e1xuICAgIGlmICgnZ2V0UHVibGljUGF0aCcgaW4gbW9kdWxlKSB7XG4gICAgICAgIGxldCBwdWJsaWNQYXRoO1xuICAgICAgICBpZiAoIW1vZHVsZS5nZXRQdWJsaWNQYXRoLnN0YXJ0c1dpdGgoJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHB1YmxpY1BhdGggPSBuZXcgRnVuY3Rpb24obW9kdWxlLmdldFB1YmxpY1BhdGgpKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdWJsaWNQYXRoID0gbmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIG1vZHVsZS5nZXRQdWJsaWNQYXRoKSgpKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3B1YmxpY1BhdGh9JHtzb3VyY2VVcmx9YDtcbiAgICB9IGVsc2UgaWYgKCdwdWJsaWNQYXRoJyBpbiBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIGAke21vZHVsZS5wdWJsaWNQYXRofSR7c291cmNlVXJsfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgZ2V0IHJlc291cmNlIFVSTC4gSWYgaW4gZGVidWcgbW9kZSwgcGxlYXNlIGlnbm9yZS4nLCBtb2R1bGUsIHNvdXJjZVVybCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmNvbnN0IGFzc2VydCA9IChjb25kaXRpb24sIG1zZyk9PntcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICBlcnJvcihtc2cpO1xuICAgIH1cbn07XG5jb25zdCBlcnJvciA9IChtc2cpPT57XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke0xPR19DQVRFR09SWX06ICR7bXNnfWApO1xufTtcbmNvbnN0IHdhcm4gPSAobXNnKT0+e1xuICAgIGNvbnNvbGUud2FybihgJHtMT0dfQ0FURUdPUll9OiAke21zZ31gKTtcbn07XG5mdW5jdGlvbiBzYWZlVG9TdHJpbmcoaW5mbykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShpbmZvLCBudWxsLCAyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4vLyBSZWdFeHAgZm9yIHZlcnNpb24gc3RyaW5nXG5jb25zdCBWRVJTSU9OX1BBVFRFUk5fUkVHRVhQID0gL14oW1xcZF49djw+fl18Wyp4WF0kKS87XG5mdW5jdGlvbiBpc1JlcXVpcmVkVmVyc2lvbihzdHIpIHtcbiAgICByZXR1cm4gVkVSU0lPTl9QQVRURVJOX1JFR0VYUC50ZXN0KHN0cik7XG59XG5cbmNvbnN0IHNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IChyUGF0aCwgck5hbWUpPT57XG4gICAgaWYgKCFyUGF0aCkge1xuICAgICAgICByZXR1cm4gck5hbWU7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zZm9ybVBhdGggPSAoc3RyKT0+e1xuICAgICAgICBpZiAoc3RyID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgnLi8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0ci5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cldpdGhvdXRTbGFzaCA9IHN0ci5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChzdHJXaXRob3V0U2xhc2guZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJXaXRob3V0U2xhc2guc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cldpdGhvdXRTbGFzaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH07XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQYXRoID0gdHJhbnNmb3JtUGF0aChyUGF0aCk7XG4gICAgaWYgKCF0cmFuc2Zvcm1lZFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHJOYW1lO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtZWRQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3RyYW5zZm9ybWVkUGF0aH0ke3JOYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt0cmFuc2Zvcm1lZFBhdGh9LyR7ck5hbWV9YDtcbn07XG5mdW5jdGlvbiBpbmZlckF1dG9QdWJsaWNQYXRoKHVybCkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvIy4qJC8sICcnKS5yZXBsYWNlKC9cXD8uKiQvLCAnJykucmVwbGFjZSgvXFwvW15cXC9dKyQvLCAnLycpO1xufVxuLy8gUHJpb3JpdHk6IG92ZXJyaWRlcyA+IHJlbW90ZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uXG5mdW5jdGlvbiBnZW5lcmF0ZVNuYXBzaG90RnJvbU1hbmlmZXN0KG1hbmlmZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX21hbmlmZXN0X21ldGFEYXRhLCBfbWFuaWZlc3RfbWV0YURhdGExO1xuICAgIGNvbnN0IHsgcmVtb3RlcyA9IHt9LCBvdmVycmlkZXMgPSB7fSwgdmVyc2lvbiB9ID0gb3B0aW9ucztcbiAgICBsZXQgcmVtb3RlU25hcHNob3Q7XG4gICAgY29uc3QgZ2V0UHVibGljUGF0aCA9ICgpPT57XG4gICAgICAgIGlmICgncHVibGljUGF0aCcgaW4gbWFuaWZlc3QubWV0YURhdGEpIHtcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdC5tZXRhRGF0YS5wdWJsaWNQYXRoID09PSAnYXV0bycgJiYgdmVyc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHB1YmxpY1BhdGggYXV0byBydW50aW1lIG1vZHVsZSBpbXBsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZmVyQXV0b1B1YmxpY1BhdGgodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QubWV0YURhdGEucHVibGljUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYW5pZmVzdC5tZXRhRGF0YS5nZXRQdWJsaWNQYXRoO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvdmVycmlkZXNLZXlzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKTtcbiAgICBsZXQgcmVtb3Rlc0luZm8gPSB7fTtcbiAgICAvLyBJZiByZW1vdGVzIGFyZSBub3QgcHJvdmlkZWQsIG9ubHkgdGhlIHJlbW90ZXMgaW4gdGhlIG1hbmlmZXN0IHdpbGwgYmUgcmVhZFxuICAgIGlmICghT2JqZWN0LmtleXMocmVtb3RlcykubGVuZ3RoKSB7XG4gICAgICAgIHZhciBfbWFuaWZlc3RfcmVtb3RlcztcbiAgICAgICAgcmVtb3Rlc0luZm8gPSAoKF9tYW5pZmVzdF9yZW1vdGVzID0gbWFuaWZlc3QucmVtb3RlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9yZW1vdGVzLnJlZHVjZSgocmVzLCBuZXh0KT0+e1xuICAgICAgICAgICAgbGV0IG1hdGNoZWRWZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5leHQuZmVkZXJhdGlvbkNvbnRhaW5lck5hbWU7XG4gICAgICAgICAgICAvLyBvdmVycmlkZXMgaGF2ZSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXNLZXlzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb24gPSBvdmVycmlkZXNbbmFtZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgndmVyc2lvbicgaW4gbmV4dCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVmVyc2lvbiA9IG5leHQuZW50cnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRWZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwge30pKSB8fCB7fTtcbiAgICB9XG4gICAgLy8gSWYgcmVtb3RlcyAoZGVwbG95IHNjZW5hcmlvKSBhcmUgc3BlY2lmaWVkLCB0aGV5IG5lZWQgdG8gYmUgdHJhdmVyc2VkIGFnYWluXG4gICAgT2JqZWN0LmtleXMocmVtb3RlcykuZm9yRWFjaCgoa2V5KT0+cmVtb3Rlc0luZm9ba2V5XSA9IHtcbiAgICAgICAgICAgIC8vIG92ZXJyaWRlcyB3aWxsIG92ZXJyaWRlIGRlcGVuZGVuY2llc1xuICAgICAgICAgICAgbWF0Y2hlZFZlcnNpb246IG92ZXJyaWRlc0tleXMuaW5jbHVkZXMoa2V5KSA/IG92ZXJyaWRlc1trZXldIDogcmVtb3Rlc1trZXldXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHsgcmVtb3RlRW50cnk6IHsgcGF0aDogcmVtb3RlRW50cnlQYXRoLCBuYW1lOiByZW1vdGVFbnRyeU5hbWUsIHR5cGU6IHJlbW90ZUVudHJ5VHlwZSB9LCB0eXBlczogcmVtb3RlVHlwZXMsIGJ1aWxkSW5mbzogeyBidWlsZFZlcnNpb24gfSwgZ2xvYmFsTmFtZSwgc3NyUmVtb3RlRW50cnkgfSA9IG1hbmlmZXN0Lm1ldGFEYXRhO1xuICAgIGNvbnN0IHsgZXhwb3NlcyB9ID0gbWFuaWZlc3Q7XG4gICAgbGV0IGJhc2ljUmVtb3RlU25hcHNob3QgPSB7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24gPyB2ZXJzaW9uIDogJycsXG4gICAgICAgIGJ1aWxkVmVyc2lvbixcbiAgICAgICAgZ2xvYmFsTmFtZSxcbiAgICAgICAgcmVtb3RlRW50cnk6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVFbnRyeVBhdGgsIHJlbW90ZUVudHJ5TmFtZSksXG4gICAgICAgIHJlbW90ZUVudHJ5VHlwZSxcbiAgICAgICAgcmVtb3RlVHlwZXM6IHNpbXBsZUpvaW5SZW1vdGVFbnRyeShyZW1vdGVUeXBlcy5wYXRoLCByZW1vdGVUeXBlcy5uYW1lKSxcbiAgICAgICAgcmVtb3RlVHlwZXNaaXA6IHJlbW90ZVR5cGVzLnppcCB8fCAnJyxcbiAgICAgICAgcmVtb3RlVHlwZXNBUEk6IHJlbW90ZVR5cGVzLmFwaSB8fCAnJyxcbiAgICAgICAgcmVtb3Rlc0luZm8sXG4gICAgICAgIHNoYXJlZDogbWFuaWZlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IG1hbmlmZXN0LnNoYXJlZC5tYXAoKGl0ZW0pPT4oe1xuICAgICAgICAgICAgICAgIGFzc2V0czogaXRlbS5hc3NldHMsXG4gICAgICAgICAgICAgICAgc2hhcmVkTmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IGl0ZW0udmVyc2lvblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICBtb2R1bGVzOiBleHBvc2VzID09IG51bGwgPyB2b2lkIDAgOiBleHBvc2VzLm1hcCgoZXhwb3NlKT0+KHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBleHBvc2UubmFtZSxcbiAgICAgICAgICAgICAgICBtb2R1bGVQYXRoOiBleHBvc2UucGF0aCxcbiAgICAgICAgICAgICAgICBhc3NldHM6IGV4cG9zZS5hc3NldHNcbiAgICAgICAgICAgIH0pKVxuICAgIH07XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGEgPSBtYW5pZmVzdC5tZXRhRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYW5pZmVzdF9tZXRhRGF0YS5wcmVmZXRjaEludGVyZmFjZSkge1xuICAgICAgICBjb25zdCBwcmVmZXRjaEludGVyZmFjZSA9IG1hbmlmZXN0Lm1ldGFEYXRhLnByZWZldGNoSW50ZXJmYWNlO1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gcG9seWZpbGxzLl9leHRlbmRzKHt9LCBiYXNpY1JlbW90ZVNuYXBzaG90LCB7XG4gICAgICAgICAgICBwcmVmZXRjaEludGVyZmFjZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKChfbWFuaWZlc3RfbWV0YURhdGExID0gbWFuaWZlc3QubWV0YURhdGEpID09IG51bGwgPyB2b2lkIDAgOiBfbWFuaWZlc3RfbWV0YURhdGExLnByZWZldGNoRW50cnkpIHtcbiAgICAgICAgY29uc3QgeyBwYXRoLCBuYW1lLCB0eXBlIH0gPSBtYW5pZmVzdC5tZXRhRGF0YS5wcmVmZXRjaEVudHJ5O1xuICAgICAgICBiYXNpY1JlbW90ZVNuYXBzaG90ID0gcG9seWZpbGxzLl9leHRlbmRzKHt9LCBiYXNpY1JlbW90ZVNuYXBzaG90LCB7XG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5OiBzaW1wbGVKb2luUmVtb3RlRW50cnkocGF0aCwgbmFtZSksXG4gICAgICAgICAgICBwcmVmZXRjaEVudHJ5VHlwZTogdHlwZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCdwdWJsaWNQYXRoJyBpbiBtYW5pZmVzdC5tZXRhRGF0YSkge1xuICAgICAgICByZW1vdGVTbmFwc2hvdCA9IHBvbHlmaWxscy5fZXh0ZW5kcyh7fSwgYmFzaWNSZW1vdGVTbmFwc2hvdCwge1xuICAgICAgICAgICAgcHVibGljUGF0aDogZ2V0UHVibGljUGF0aCgpXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90ID0gcG9seWZpbGxzLl9leHRlbmRzKHt9LCBiYXNpY1JlbW90ZVNuYXBzaG90LCB7XG4gICAgICAgICAgICBnZXRQdWJsaWNQYXRoOiBnZXRQdWJsaWNQYXRoKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzc3JSZW1vdGVFbnRyeSkge1xuICAgICAgICBjb25zdCBmdWxsU1NSUmVtb3RlRW50cnkgPSBzaW1wbGVKb2luUmVtb3RlRW50cnkoc3NyUmVtb3RlRW50cnkucGF0aCwgc3NyUmVtb3RlRW50cnkubmFtZSk7XG4gICAgICAgIHJlbW90ZVNuYXBzaG90LnNzclJlbW90ZUVudHJ5ID0gZnVsbFNTUlJlbW90ZUVudHJ5O1xuICAgICAgICByZW1vdGVTbmFwc2hvdC5zc3JSZW1vdGVFbnRyeVR5cGUgPSBzc3JSZW1vdGVFbnRyeS50eXBlIHx8ICdjb21tb25qcy1tb2R1bGUnO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3RlU25hcHNob3Q7XG59XG5mdW5jdGlvbiBpc01hbmlmZXN0UHJvdmlkZXIobW9kdWxlSW5mbykge1xuICAgIGlmICgncmVtb3RlRW50cnknIGluIG1vZHVsZUluZm8gJiYgbW9kdWxlSW5mby5yZW1vdGVFbnRyeS5pbmNsdWRlcyhNQU5JRkVTVF9FWFQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5hc3luYyBmdW5jdGlvbiBzYWZlV3JhcHBlcihjYWxsYmFjaywgZGlzYWJsZVdhcm4pIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgIWRpc2FibGVXYXJuICYmIHdhcm4oZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKHVybDEsIHVybDIpIHtcbiAgICBjb25zdCBSRUdfRVhQID0gL14oaHR0cHM/Oik/XFwvXFwvL2k7XG4gICAgLy8gVHJhbnNmb3JtIHVybDEgYW5kIHVybDIgaW50byByZWxhdGl2ZSBwYXRoc1xuICAgIGNvbnN0IHJlbGF0aXZlVXJsMSA9IHVybDEucmVwbGFjZShSRUdfRVhQLCAnJykucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICBjb25zdCByZWxhdGl2ZVVybDIgPSB1cmwyLnJlcGxhY2UoUkVHX0VYUCwgJycpLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlbGF0aXZlIHBhdGhzIGFyZSBpZGVudGljYWxcbiAgICByZXR1cm4gcmVsYXRpdmVVcmwxID09PSByZWxhdGl2ZVVybDI7XG59XG5mdW5jdGlvbiBjcmVhdGVTY3JpcHQoaW5mbykge1xuICAgIC8vIFJldHJpZXZlIHRoZSBleGlzdGluZyBzY3JpcHQgZWxlbWVudCBieSBpdHMgc3JjIGF0dHJpYnV0ZVxuICAgIGxldCBzY3JpcHQgPSBudWxsO1xuICAgIGxldCBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICBsZXQgdGltZW91dCA9IDIwMDAwO1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3Qgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHMgPSBzY3JpcHRzW2ldO1xuICAgICAgICBjb25zdCBzY3JpcHRTcmMgPSBzLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIGlmIChzY3JpcHRTcmMgJiYgaXNTdGF0aWNSZXNvdXJjZXNFcXVhbChzY3JpcHRTcmMsIGluZm8udXJsKSkge1xuICAgICAgICAgICAgc2NyaXB0ID0gcztcbiAgICAgICAgICAgIG5lZWRBdHRhY2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2NyaXB0KSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gaW5mby5hdHRycztcbiAgICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNjcmlwdC50eXBlID0gKGF0dHJzID09IG51bGwgPyB2b2lkIDAgOiBhdHRyc1sndHlwZSddKSA9PT0gJ21vZHVsZScgPyAnbW9kdWxlJyA6ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBsZXQgY3JlYXRlU2NyaXB0UmVzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoaW5mby5jcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgICAgICAgICBjcmVhdGVTY3JpcHRSZXMgPSBpbmZvLmNyZWF0ZVNjcmlwdEhvb2soaW5mby51cmwsIGluZm8uYXR0cnMpO1xuICAgICAgICAgICAgaWYgKGNyZWF0ZVNjcmlwdFJlcyBpbnN0YW5jZW9mIEhUTUxTY3JpcHRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gY3JlYXRlU2NyaXB0UmVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3JlYXRlU2NyaXB0UmVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGlmICgnc2NyaXB0JyBpbiBjcmVhdGVTY3JpcHRSZXMgJiYgY3JlYXRlU2NyaXB0UmVzLnNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBjcmVhdGVTY3JpcHRSZXMuc2NyaXB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoJ3RpbWVvdXQnIGluIGNyZWF0ZVNjcmlwdFJlcyAmJiBjcmVhdGVTY3JpcHRSZXMudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gY3JlYXRlU2NyaXB0UmVzLnRpbWVvdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2NyaXB0LnNyYykge1xuICAgICAgICAgICAgc2NyaXB0LnNyYyA9IGluZm8udXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycyAmJiAhY3JlYXRlU2NyaXB0UmVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaCgobmFtZSk9PntcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnYXN5bmMnIHx8IG5hbWUgPT09ICdkZWZlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdFtuYW1lXSA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIHRoYXQgZG8gbm90IGV4aXN0IGFyZSBjb25zaWRlcmVkIG92ZXJyaWRkZW5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghc2NyaXB0LmdldEF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvblNjcmlwdENvbXBsZXRlID0gYXN5bmMgKHByZXYsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXZlbnQpPT57XG4gICAgICAgIHZhciBfaW5mb19jYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFLlxuICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICBzY3JpcHQub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNhZmVXcmFwcGVyKCgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZWVkRGVsZXRlU2NyaXB0ID0gdHJ1ZSB9ID0gaW5mbztcbiAgICAgICAgICAgICAgICBpZiAobmVlZERlbGV0ZVNjcmlwdCkge1xuICAgICAgICAgICAgICAgICAgICAoc2NyaXB0ID09IG51bGwgPyB2b2lkIDAgOiBzY3JpcHQucGFyZW50Tm9kZSkgJiYgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHR5cGVvZiBwcmV2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pbmZvX2NiMTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2luZm9fY2IyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5mb19jYjIgPSBpbmZvLmNiKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fY2IyLmNhbGwoaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZm8gPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5mb19jYjEgPSBpbmZvLmNiKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fY2IxLmNhbGwoaW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fY2IgPSBpbmZvLmNiKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fY2IuY2FsbChpbmZvKTtcbiAgICB9O1xuICAgIHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcbiAgICBzY3JpcHQub25sb2FkID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmxvYWQpO1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgb25TY3JpcHRDb21wbGV0ZShudWxsLCBuZXcgRXJyb3IoYFJlbW90ZSBzY3JpcHQgXCIke2luZm8udXJsfVwiIHRpbWUtb3V0ZWQuYCkpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgbmVlZEF0dGFjaFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVMaW5rKGluZm8pIHtcbiAgICAvLyA8bGluayByZWw9XCJwcmVsb2FkXCIgaHJlZj1cInNjcmlwdC5qc1wiIGFzPVwic2NyaXB0XCI+XG4gICAgLy8gUmV0cmlldmUgdGhlIGV4aXN0aW5nIHNjcmlwdCBlbGVtZW50IGJ5IGl0cyBzcmMgYXR0cmlidXRlXG4gICAgbGV0IGxpbmsgPSBudWxsO1xuICAgIGxldCBuZWVkQXR0YWNoID0gdHJ1ZTtcbiAgICBjb25zdCBsaW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgbCA9IGxpbmtzW2ldO1xuICAgICAgICBjb25zdCBsaW5rSHJlZiA9IGwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgIGNvbnN0IGxpbmtSZWYgPSBsLmdldEF0dHJpYnV0ZSgncmVmJyk7XG4gICAgICAgIGlmIChsaW5rSHJlZiAmJiBpc1N0YXRpY1Jlc291cmNlc0VxdWFsKGxpbmtIcmVmLCBpbmZvLnVybCkgJiYgbGlua1JlZiA9PT0gaW5mby5hdHRyc1sncmVmJ10pIHtcbiAgICAgICAgICAgIGxpbmsgPSBsO1xuICAgICAgICAgICAgbmVlZEF0dGFjaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsaW5rKSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKCdocmVmJywgaW5mby51cmwpO1xuICAgICAgICBsZXQgY3JlYXRlTGlua1JlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBpbmZvLmF0dHJzO1xuICAgICAgICBpZiAoaW5mby5jcmVhdGVMaW5rSG9vaykge1xuICAgICAgICAgICAgY3JlYXRlTGlua1JlcyA9IGluZm8uY3JlYXRlTGlua0hvb2soaW5mby51cmwsIGF0dHJzKTtcbiAgICAgICAgICAgIGlmIChjcmVhdGVMaW5rUmVzIGluc3RhbmNlb2YgSFRNTExpbmtFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbGluayA9IGNyZWF0ZUxpbmtSZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJzICYmICFjcmVhdGVMaW5rUmVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaCgobmFtZSk9PntcbiAgICAgICAgICAgICAgICBpZiAobGluayAmJiAhbGluay5nZXRBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9uTGlua0NvbXBsZXRlID0gKHByZXYsIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXZlbnQpPT57XG4gICAgICAgIC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzIGluIElFLlxuICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgbGluay5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGxpbmsub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIHNhZmVXcmFwcGVyKCgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZWVkRGVsZXRlTGluayA9IHRydWUgfSA9IGluZm87XG4gICAgICAgICAgICAgICAgaWYgKG5lZWREZWxldGVMaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIChsaW5rID09IG51bGwgPyB2b2lkIDAgOiBsaW5rLnBhcmVudE5vZGUpICYmIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBwcmV2KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpbmZvLmNiKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmZvLmNiKCk7XG4gICAgfTtcbiAgICBsaW5rLm9uZXJyb3IgPSBvbkxpbmtDb21wbGV0ZS5iaW5kKG51bGwsIGxpbmsub25lcnJvcik7XG4gICAgbGluay5vbmxvYWQgPSBvbkxpbmtDb21wbGV0ZS5iaW5kKG51bGwsIGxpbmsub25sb2FkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5rLFxuICAgICAgICBuZWVkQXR0YWNoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxvYWRTY3JpcHQodXJsLCBpbmZvKSB7XG4gICAgY29uc3QgeyBhdHRycyA9IHt9LCBjcmVhdGVTY3JpcHRIb29rIH0gPSBpbmZvO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgX3JlamVjdCk9PntcbiAgICAgICAgY29uc3QgeyBzY3JpcHQsIG5lZWRBdHRhY2ggfSA9IGNyZWF0ZVNjcmlwdCh7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBjYjogcmVzb2x2ZSxcbiAgICAgICAgICAgIGF0dHJzOiBwb2x5ZmlsbHMuX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIGZldGNocHJpb3JpdHk6ICdoaWdoJ1xuICAgICAgICAgICAgfSwgYXR0cnMpLFxuICAgICAgICAgICAgY3JlYXRlU2NyaXB0SG9vayxcbiAgICAgICAgICAgIG5lZWREZWxldGVTY3JpcHQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG5lZWRBdHRhY2ggJiYgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpbXBvcnROb2RlTW9kdWxlKG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvcnQgc3BlY2lmaWVyIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGltcG9ydE1vZHVsZSA9IG5ldyBGdW5jdGlvbignbmFtZScsIGByZXR1cm4gaW1wb3J0KG5hbWUpYCk7XG4gICAgcmV0dXJuIGltcG9ydE1vZHVsZShuYW1lKS50aGVuKChyZXMpPT5yZXMpLmNhdGNoKChlcnJvcik9PntcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW1wb3J0aW5nIG1vZHVsZSAke25hbWV9OmAsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG59XG5jb25zdCBsb2FkTm9kZUZldGNoID0gYXN5bmMgKCk9PntcbiAgICBjb25zdCBmZXRjaE1vZHVsZSA9IGF3YWl0IGltcG9ydE5vZGVNb2R1bGUoJ25vZGUtZmV0Y2gnKTtcbiAgICByZXR1cm4gZmV0Y2hNb2R1bGUuZGVmYXVsdCB8fCBmZXRjaE1vZHVsZTtcbn07XG5jb25zdCBsYXp5TG9hZGVySG9va0ZldGNoID0gYXN5bmMgKGlucHV0LCBpbml0LCBsb2FkZXJIb29rKT0+e1xuICAgIGNvbnN0IGhvb2sgPSAodXJsLCBpbml0KT0+e1xuICAgICAgICByZXR1cm4gbG9hZGVySG9vay5saWZlY3ljbGUuZmV0Y2guZW1pdCh1cmwsIGluaXQpO1xuICAgIH07XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaG9vayhpbnB1dCwgaW5pdCB8fCB7fSk7XG4gICAgaWYgKCFyZXMgfHwgIShyZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgICAgY29uc3QgZmV0Y2hGdW5jdGlvbiA9IHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcgPyBhd2FpdCBsb2FkTm9kZUZldGNoKCkgOiBmZXRjaDtcbiAgICAgICAgcmV0dXJuIGZldGNoRnVuY3Rpb24oaW5wdXQsIGluaXQgfHwge30pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVNjcmlwdE5vZGUodXJsLCBjYiwgYXR0cnMsIGxvYWRlckhvb2spIHtcbiAgICBpZiAobG9hZGVySG9vayA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVySG9vay5jcmVhdGVTY3JpcHRIb29rKSB7XG4gICAgICAgIGNvbnN0IGhvb2tSZXN1bHQgPSBsb2FkZXJIb29rLmNyZWF0ZVNjcmlwdEhvb2sodXJsKTtcbiAgICAgICAgaWYgKGhvb2tSZXN1bHQgJiYgdHlwZW9mIGhvb2tSZXN1bHQgPT09ICdvYmplY3QnICYmICd1cmwnIGluIGhvb2tSZXN1bHQpIHtcbiAgICAgICAgICAgIHVybCA9IGhvb2tSZXN1bHQudXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB1cmxPYmo7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsT2JqID0gbmV3IFVSTCh1cmwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29uc3RydWN0aW5nIFVSTDonLCBlKTtcbiAgICAgICAgY2IobmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHtlfWApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnZXRGZXRjaCA9IGFzeW5jICgpPT57XG4gICAgICAgIGlmIChsb2FkZXJIb29rID09IG51bGwgPyB2b2lkIDAgOiBsb2FkZXJIb29rLmZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlucHV0LCBpbml0KT0+bGF6eUxvYWRlckhvb2tGZXRjaChpbnB1dCwgaW5pdCwgbG9hZGVySG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmZXRjaCA9PT0gJ3VuZGVmaW5lZCcgPyBsb2FkTm9kZUZldGNoKCkgOiBmZXRjaDtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVNjcmlwdEZldGNoID0gYXN5bmMgKGYsIHVybE9iaik9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIF92bV9jb25zdGFudHM7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmKHVybE9iai5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgW3BhdGgsIHZtXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBpbXBvcnROb2RlTW9kdWxlKCdwYXRoJyksXG4gICAgICAgICAgICAgICAgaW1wb3J0Tm9kZU1vZHVsZSgndm0nKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHRDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICAgICAgICAgIG1vZHVsZToge1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cmxEaXJuYW1lID0gdXJsT2JqLnBhdGhuYW1lLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5iYXNlbmFtZSh1cmxPYmoucGF0aG5hbWUpO1xuICAgICAgICAgICAgdmFyIF92bV9jb25zdGFudHNfVVNFX01BSU5fQ09OVEVYVF9ERUZBVUxUX0xPQURFUjtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IG5ldyB2bS5TY3JpcHQoYChmdW5jdGlvbihleHBvcnRzLCBtb2R1bGUsIHJlcXVpcmUsIF9fZGlybmFtZSwgX19maWxlbmFtZSkgeyR7ZGF0YX1cXG59KWAsIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBpbXBvcnRNb2R1bGVEeW5hbWljYWxseTogKF92bV9jb25zdGFudHNfVVNFX01BSU5fQ09OVEVYVF9ERUZBVUxUX0xPQURFUiA9IChfdm1fY29uc3RhbnRzID0gdm0uY29uc3RhbnRzKSA9PSBudWxsID8gdm9pZCAwIDogX3ZtX2NvbnN0YW50cy5VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSKSAhPSBudWxsID8gX3ZtX2NvbnN0YW50c19VU0VfTUFJTl9DT05URVhUX0RFRkFVTFRfTE9BREVSIDogaW1wb3J0Tm9kZU1vZHVsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzY3JpcHQucnVuSW5UaGlzQ29udGV4dCgpKHNjcmlwdENvbnRleHQuZXhwb3J0cywgc2NyaXB0Q29udGV4dC5tb2R1bGUsIGV2YWwoJ3JlcXVpcmUnKSwgdXJsRGlybmFtZSwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRJbnRlcmZhY2UgPSBzY3JpcHRDb250ZXh0Lm1vZHVsZS5leHBvcnRzIHx8IHNjcmlwdENvbnRleHQuZXhwb3J0cztcbiAgICAgICAgICAgIGlmIChhdHRycyAmJiBleHBvcnRlZEludGVyZmFjZSAmJiBhdHRyc1snZ2xvYmFsTmFtZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gZXhwb3J0ZWRJbnRlcmZhY2VbYXR0cnNbJ2dsb2JhbE5hbWUnXV0gfHwgZXhwb3J0ZWRJbnRlcmZhY2U7XG4gICAgICAgICAgICAgICAgY2IodW5kZWZpbmVkLCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgZXhwb3J0ZWRJbnRlcmZhY2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjYihlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKGBTY3JpcHQgZXhlY3V0aW9uIGVycm9yOiAke2V9YCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBnZXRGZXRjaCgpLnRoZW4oYXN5bmMgKGYpPT57XG4gICAgICAgIGlmICgoYXR0cnMgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJzWyd0eXBlJ10pID09PSAnZXNtJyB8fCAoYXR0cnMgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJzWyd0eXBlJ10pID09PSAnbW9kdWxlJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRNb2R1bGUodXJsT2JqLmhyZWYsIHtcbiAgICAgICAgICAgICAgICBmZXRjaDogZixcbiAgICAgICAgICAgICAgICB2bTogYXdhaXQgaW1wb3J0Tm9kZU1vZHVsZSgndm0nKVxuICAgICAgICAgICAgfSkudGhlbihhc3luYyAobW9kdWxlKT0+e1xuICAgICAgICAgICAgICAgIGF3YWl0IG1vZHVsZS5ldmFsdWF0ZSgpO1xuICAgICAgICAgICAgICAgIGNiKHVuZGVmaW5lZCwgbW9kdWxlLm5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZSk9PntcbiAgICAgICAgICAgICAgICBjYihlIGluc3RhbmNlb2YgRXJyb3IgPyBlIDogbmV3IEVycm9yKGBTY3JpcHQgZXhlY3V0aW9uIGVycm9yOiAke2V9YCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlU2NyaXB0RmV0Y2goZiwgdXJsT2JqKTtcbiAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICBjYihlcnIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbG9hZFNjcmlwdE5vZGUodXJsLCBpbmZvKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNyZWF0ZVNjcmlwdE5vZGUodXJsLCAoZXJyb3IsIHNjcmlwdENvbnRleHQpPT57XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luZm9fYXR0cnMsIF9pbmZvX2F0dHJzMTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVFbnRyeUtleSA9IChpbmZvID09IG51bGwgPyB2b2lkIDAgOiAoX2luZm9fYXR0cnMgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnNbJ2dsb2JhbE5hbWUnXSkgfHwgYF9fRkVERVJBVElPTl8ke2luZm8gPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5mb19hdHRyczEgPSBpbmZvLmF0dHJzKSA9PSBudWxsID8gdm9pZCAwIDogX2luZm9fYXR0cnMxWyduYW1lJ119OmN1c3RvbV9fYDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeUV4cG9ydHMgPSBnbG9iYWxUaGlzW3JlbW90ZUVudHJ5S2V5XSA9IHNjcmlwdENvbnRleHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShlbnRyeUV4cG9ydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpbmZvLmF0dHJzLCBpbmZvLmxvYWRlckhvb2spO1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZE1vZHVsZSh1cmwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGZldGNoOiBmZXRjaDEsIHZtIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gxKHVybCk7XG4gICAgY29uc3QgY29kZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBjb25zdCBtb2R1bGUgPSBuZXcgdm0uU291cmNlVGV4dE1vZHVsZShjb2RlLCB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaW1wb3J0TW9kdWxlRHluYW1pY2FsbHk6IGFzeW5jIChzcGVjaWZpZXIsIHNjcmlwdCk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkVXJsID0gbmV3IFVSTChzcGVjaWZpZXIsIHVybCkuaHJlZjtcbiAgICAgICAgICAgIHJldHVybiBsb2FkTW9kdWxlKHJlc29sdmVkVXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IG1vZHVsZS5saW5rKGFzeW5jIChzcGVjaWZpZXIpPT57XG4gICAgICAgIGNvbnN0IHJlc29sdmVkVXJsID0gbmV3IFVSTChzcGVjaWZpZXIsIHVybCkuaHJlZjtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gYXdhaXQgbG9hZE1vZHVsZShyZXNvbHZlZFVybCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZHVsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhlbmFibGVEZWZhdWx0LCBkZWZhdWx0T3B0aW9ucywga2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlmaWxscy5fZXh0ZW5kcyh7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB0eXBlIGZvciBcXGAke2tleX1cXGAsIGV4cGVjdCBib29sZWFuL3VuZGVmaW5lZC9vYmplY3QsIGdvdDogJHt0eXBlb2Ygb3B0aW9uc31gKTtcbiAgICB9O1xufVxuXG5leHBvcnRzLkJST1dTRVJfTE9HX0tFWSA9IEJST1dTRVJfTE9HX0tFWTtcbmV4cG9ydHMuQlJPV1NFUl9MT0dfVkFMVUUgPSBCUk9XU0VSX0xPR19WQUxVRTtcbmV4cG9ydHMuRU5DT0RFX05BTUVfUFJFRklYID0gRU5DT0RFX05BTUVfUFJFRklYO1xuZXhwb3J0cy5FbmNvZGVkTmFtZVRyYW5zZm9ybU1hcCA9IEVuY29kZWROYW1lVHJhbnNmb3JtTWFwO1xuZXhwb3J0cy5GZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3QgPSBGZWRlcmF0aW9uTW9kdWxlTWFuaWZlc3Q7XG5leHBvcnRzLk1BTklGRVNUX0VYVCA9IE1BTklGRVNUX0VYVDtcbmV4cG9ydHMuTUZNb2R1bGVUeXBlID0gTUZNb2R1bGVUeXBlO1xuZXhwb3J0cy5NRlByZWZldGNoQ29tbW9uID0gTUZQcmVmZXRjaENvbW1vbjtcbmV4cG9ydHMuTU9EVUxFX0RFVlRPT0xfSURFTlRJRklFUiA9IE1PRFVMRV9ERVZUT09MX0lERU5USUZJRVI7XG5leHBvcnRzLk1hbmlmZXN0RmlsZU5hbWUgPSBNYW5pZmVzdEZpbGVOYW1lO1xuZXhwb3J0cy5OYW1lVHJhbnNmb3JtTWFwID0gTmFtZVRyYW5zZm9ybU1hcDtcbmV4cG9ydHMuTmFtZVRyYW5zZm9ybVN5bWJvbCA9IE5hbWVUcmFuc2Zvcm1TeW1ib2w7XG5leHBvcnRzLlNFUEFSQVRPUiA9IFNFUEFSQVRPUjtcbmV4cG9ydHMuU3RhdHNGaWxlTmFtZSA9IFN0YXRzRmlsZU5hbWU7XG5leHBvcnRzLlRFTVBfRElSID0gVEVNUF9ESVI7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuY29tcG9zZUtleVdpdGhTZXBhcmF0b3IgPSBjb21wb3NlS2V5V2l0aFNlcGFyYXRvcjtcbmV4cG9ydHMuY29udGFpbmVyUGx1Z2luID0gQ29udGFpbmVyUGx1Z2luO1xuZXhwb3J0cy5jb250YWluZXJSZWZlcmVuY2VQbHVnaW4gPSBDb250YWluZXJSZWZlcmVuY2VQbHVnaW47XG5leHBvcnRzLmNyZWF0ZUxpbmsgPSBjcmVhdGVMaW5rO1xuZXhwb3J0cy5jcmVhdGVMb2dnZXIgPSBjcmVhdGVMb2dnZXI7XG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGNyZWF0ZVNjcmlwdDtcbmV4cG9ydHMuY3JlYXRlU2NyaXB0Tm9kZSA9IGNyZWF0ZVNjcmlwdE5vZGU7XG5leHBvcnRzLmRlY29kZU5hbWUgPSBkZWNvZGVOYW1lO1xuZXhwb3J0cy5lbmNvZGVOYW1lID0gZW5jb2RlTmFtZTtcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmV4cG9ydHMuZ2VuZXJhdGVFeHBvc2VGaWxlbmFtZSA9IGdlbmVyYXRlRXhwb3NlRmlsZW5hbWU7XG5leHBvcnRzLmdlbmVyYXRlU2hhcmVGaWxlbmFtZSA9IGdlbmVyYXRlU2hhcmVGaWxlbmFtZTtcbmV4cG9ydHMuZ2VuZXJhdGVTbmFwc2hvdEZyb21NYW5pZmVzdCA9IGdlbmVyYXRlU25hcHNob3RGcm9tTWFuaWZlc3Q7XG5leHBvcnRzLmdldFByb2Nlc3NFbnYgPSBnZXRQcm9jZXNzRW52O1xuZXhwb3J0cy5nZXRSZXNvdXJjZVVybCA9IGdldFJlc291cmNlVXJsO1xuZXhwb3J0cy5pbmZlckF1dG9QdWJsaWNQYXRoID0gaW5mZXJBdXRvUHVibGljUGF0aDtcbmV4cG9ydHMuaXNCcm93c2VyRW52ID0gaXNCcm93c2VyRW52O1xuZXhwb3J0cy5pc0RlYnVnTW9kZSA9IGlzRGVidWdNb2RlO1xuZXhwb3J0cy5pc01hbmlmZXN0UHJvdmlkZXIgPSBpc01hbmlmZXN0UHJvdmlkZXI7XG5leHBvcnRzLmlzUmVxdWlyZWRWZXJzaW9uID0gaXNSZXF1aXJlZFZlcnNpb247XG5leHBvcnRzLmlzU3RhdGljUmVzb3VyY2VzRXF1YWwgPSBpc1N0YXRpY1Jlc291cmNlc0VxdWFsO1xuZXhwb3J0cy5sb2FkU2NyaXB0ID0gbG9hZFNjcmlwdDtcbmV4cG9ydHMubG9hZFNjcmlwdE5vZGUgPSBsb2FkU2NyaXB0Tm9kZTtcbmV4cG9ydHMubG9nZ2VyID0gbG9nZ2VyO1xuZXhwb3J0cy5tb2R1bGVGZWRlcmF0aW9uUGx1Z2luID0gTW9kdWxlRmVkZXJhdGlvblBsdWdpbjtcbmV4cG9ydHMubm9ybWFsaXplT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnM7XG5leHBvcnRzLnBhcnNlRW50cnkgPSBwYXJzZUVudHJ5O1xuZXhwb3J0cy5zYWZlVG9TdHJpbmcgPSBzYWZlVG9TdHJpbmc7XG5leHBvcnRzLnNhZmVXcmFwcGVyID0gc2FmZVdyYXBwZXI7XG5leHBvcnRzLnNoYXJlUGx1Z2luID0gU2hhcmVQbHVnaW47XG5leHBvcnRzLnNpbXBsZUpvaW5SZW1vdGVFbnRyeSA9IHNpbXBsZUpvaW5SZW1vdGVFbnRyeTtcbmV4cG9ydHMud2FybiA9IHdhcm47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/index.cjs.js\n");

/***/ }),

/***/ "../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/polyfills.cjs.js":
/*!********************************************************************************************************************!*\
  !*** ../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/polyfills.cjs.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nfunction _extends() {\n    _extends = Object.assign || function assign(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n\nexports._extends = _extends;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0Btb2R1bGUtZmVkZXJhdGlvbitzZGtAMC43LjMvbm9kZV9tb2R1bGVzL0Btb2R1bGUtZmVkZXJhdGlvbi9zZGsvZGlzdC9wb2x5ZmlsbHMuY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoZWNrb3V0Ly4uL25vZGVfbW9kdWxlcy8ucG5wbS9AbW9kdWxlLWZlZGVyYXRpb24rc2RrQDAuNy4zL25vZGVfbW9kdWxlcy9AbW9kdWxlLWZlZGVyYXRpb24vc2RrL2Rpc3QvcG9seWZpbGxzLmNqcy5qcz8zYmYyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKWlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0cy5fZXh0ZW5kcyA9IF9leHRlbmRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/.pnpm/@module-federation+sdk@0.7.3/node_modules/@module-federation/sdk/dist/polyfills.cjs.js\n");

/***/ })

};
;